<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.20.2">
    <meta name="project" content="Nostrum v0.4.1">
    <title>Events â€” Nostrum v0.4.1</title>
    <link rel="stylesheet" href="dist/html-d9f58a6320b5bfa6dd77.css" />
    <script src="dist/sidebar_items-f8bbdf0059.js"></script>
      <script src="docs_config.js"></script>
    <script async src="dist/html-d9f58a6320b5bfa6dd77.js"></script>
  </head>
  <body data-type="extras">
    <script>try { if(localStorage.getItem('night-mode')) document.body.className += ' night-mode'; } catch (e) { }</script>
<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button">
      <span class="icon-search" aria-hidden="true"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button">
      <span class="icon-cross" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" id="search-list" class="search-input" placeholder="Search..." aria-label="Search" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="https://github.com/kraigie/nostrum" class="sidebar-projectName">
Nostrum      </a>
      <h2 class="sidebar-projectVersion">
        v0.4.1
      </h2>
    </div>
  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">Pages</a></li>

      <li><a id="modules-list" href="#full-list">Modules</a></li>

      <li><a id="exceptions-list" href="#full-list">Exceptions</a></li>

      <li><a id="tasks-list" href="#full-list">Mix Tasks</a></li>
  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>Events</h1>
<p>Event handling is how your bot application will interact with the information
sent from Discord over a websocket connection. By defining an event handler for
an event, when something like a message is created or a channel is deleted, your
application can perform an action as a result of that event.</p>
<p>Nostrum currently uses a <a href="https://github.com/elixir-lang/gen_stage">GenStage</a>
implementation to handle dispatching events from the WS connection. To handle
events it is up to you to define the <code class="inline">consumer</code> of the GenStage life cycle.</p>
<p>To see the documentation on using one of provided consumers, please see
<a href="Nostrum.Consumer.html"><code class="inline">Nostrum.Consumer</code></a>.</p>
<h2 id="why-genstage" class="section-heading">
  <a href="#why-genstage" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Why GenStage?
</h2>

<p>From the GenStage docs:</p>
<blockquote><p>GenStage is a specification for exchanging events between producers and consumers.</p>
</blockquote>
<p>Sounds a lot like the use case here, doesn&#39;t it?</p>
<p>An earlier implementation sent the dispatch events from the websocket directly to
user defined handlers inside of a task. This was okay, but it made handling the
events internally a bit difficult as we would either need to block the main shard
process or daisy chain tasks together. We could use a simple GenServer approach,
but at that point, why not just use GenStage? GenStage uses GenServer behind the
scenes, but abstracts away dispatching the data and providing back-pressure.</p>
<p>With the GenStage approach we have an OTP implementation of our required behaviour
that gives us separate maintainable parts with back-pressure.</p>
<h2 id="implementation-details" class="section-heading">
  <a href="#implementation-details" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Implementation Details
</h2>

<p>The following information will define the general procedure of dispatching events.</p>
<p>If you disagree with anything listed below or would like to offer a suggestion on
how it can be improved, please feel free to voice your opinion.</p>
<h3 id="shard" class="section-heading">
  <a href="#shard" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Shard
</h3>

<p>Every shard in the Nostrum application is ran as its own process. These shards
are all run under the same supervisor. As part of the setup for each shard, it
creates its own producer under a supervisor.</p>
<p>As events are sent to the shard, the following happens:</p>
<ol>
<li><p>Shard looks to see what type of event it is, only dispatch events are sent to
 the producer.</p>
</li>
<li><p>If the event is a <code class="inline">Dispatch</code>, the payload is converted to an atom-keyed map.
 This is done because over ETF (which Nostrum uses), map keys are sometimes
 binaries and sometimes strings, making it a real headache. Additionally, with
 atom keys, we can use the <code class="inline">Map.key</code> notation. This is normally considered unsafe
 but a debug messages will be emitted if a key is unsafely converted to an atom.
 In this way we can ensure that our atom table is not growing unbounded.</p>
</li>
<li><p>The payload is then sent to the relevant cache to update its state inside of
 a supervised task.</p>
</li>
<li><p>The cache sends the curated payload information to the producer. In the case
 of updates, the cache will sometimes send two payloads back, the old and the
 new payload, for comparison purposes. In general, the payload will often match
 the payload described by the official Discord API documentation.</p>
</li>
</ol>
<h3 id="producer" class="section-heading">
  <a href="#producer" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Producer
</h3>

<p>The producer is responsible for queuing up events to dispatch, as well as
dispatching these events.</p>
<ol>
<li>The producer takes the payload(s) and puts them into a queue of events to send
 to a consumer.
</li>
</ol>
<h3 id="consumer" class="section-heading">
  <a href="#consumer" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Consumer
</h3>

<p>The consumer is implemented by the user. They can spawn any number of consumers
which will in turn request events from the producers created by each shard.</p>
<p>Nostrum wraps the GenStage module to provide a simpler interface for event handling.
One of the benefits to this approach is that we can abstract away the manual linking
of producer to consumer.</p>
<p>For creating your own custom consumers, please see <a href="consumers.html">here</a>.</p>
      <footer class="footer">
        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.20.2),
          </span>
          <span class="line">
            designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>
  </body>
</html>
